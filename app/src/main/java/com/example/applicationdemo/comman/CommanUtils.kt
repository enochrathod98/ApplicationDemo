package com.example.applicationdemo.comman

import android.content.Context
import android.util.Base64
import android.widget.Toast
import com.example.applicationdemo.R
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec

object CommanUtils {
    fun isValid(email: String, password: String, baseContext: Context): Boolean {
        // Check for empty email or password
        if (email.isEmpty() || password.isEmpty()) {
            Toast.makeText(
                baseContext,
                baseContext.getString(R.string.empty_field_error_message),
                Toast.LENGTH_SHORT,
            ).show()
            return false
        }

        // Validate email format
        val emailPattern = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}".toRegex()
        if (!email.matches(emailPattern)) {
            Toast.makeText(
                baseContext,
                baseContext.getString(R.string.valid_email_error_message),
                Toast.LENGTH_SHORT,
            ).show()
            return false
        }

        // Validate password for at least one special character and one capital letter
        val specialCharPattern = "[!@#\$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]".toRegex()
        val capitalLetterPattern = "[A-Z]".toRegex()

        val hasSpecialChar = specialCharPattern.containsMatchIn(password)
        val hasCapitalLetter = capitalLetterPattern.containsMatchIn(password)
        return hasSpecialChar && hasCapitalLetter
    }

    // Function to encrypt the password
    fun encryptPassword(password: String): String {
        // Generate a random key
        val key: SecretKey = generateKey()
        // Initialize the cipher with AES encryption in GCM mode
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        // Initialize the cipher with the generated key for encryption
        cipher.init(Cipher.ENCRYPT_MODE, key)
        // Get the initialization vector (IV) generated by the cipher
        val iv = cipher.iv
        // Encrypt the password using the initialized cipher
        val encryptedText = cipher.doFinal(password.toByteArray())
        // Combine the IV and encrypted text into a single byte array
        val combined = ByteArray(iv.size + encryptedText.size)
        System.arraycopy(iv, 0, combined, 0, iv.size)
        System.arraycopy(encryptedText, 0, combined, iv.size, encryptedText.size)
        // Encode the combined byte array to Base64 string and return
        return Base64.encodeToString(combined, Base64.DEFAULT)
    }

    // Function to decrypt the password
    fun decryptPassword(encryptedPassword: String): String {
        // Decode the Base64 string to get the combined byte array
        val decodedBytes = Base64.decode(encryptedPassword, Base64.DEFAULT)
        // Extract the IV and cipher text from the combined byte array
        val iv = decodedBytes.copyOf(12)
        val cipherText = decodedBytes.copyOfRange(12, decodedBytes.size)
        // Generate the key for decryption
        val key: SecretKey = generateKey()
        // Initialize the cipher with AES decryption in GCM mode
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        // Specify the parameters including the IV for decryption
        val spec = GCMParameterSpec(128, iv)
        // Initialize the cipher with the generated key and parameters for decryption
        cipher.init(Cipher.DECRYPT_MODE, key, spec)
        // Decrypt the cipher text and return the result as a string
        val decryptedBytes = cipher.doFinal(cipherText)
        return String(decryptedBytes)
    }

    private fun generateKey(): SecretKey {
        val key = ByteArray(16)
        return SecretKeySpec(key, "AES")
    }
}